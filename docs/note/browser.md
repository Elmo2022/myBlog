> 关于浏览器的知识

## 进程和线程

进程：进程是计算机中正在进行的程序的实例，拥有独立的内存空间、代码和数据，并且由操作系统统一调度和管理。每个进程在执行时都会分配独立的内存空间，不同进程之间的内存是隔离的，一个进程错误不会直接影响其他进程。进程之间通过进程间通信（IPC）机制来交换数据和进行通信，常见的方式包括管道、消息队列、共享内存等。进程的切换开销较大，因为需要保存和恢复进程的完整状态，涉及到内存保护和虚拟内存的切换。

线程：线程是进程的子任务，一个进程可以包含多个线程。它们共享相同的代码和数据，但拥有独立的执行栈和寄存器集合。多个线程可以在同一进程内并发执行，共享进程的资源，如内存空间、打开的文件等。线程间通信和数据交换比进程间更加方便，因为它们共享相同的地址空间。线程的切换开销较小，切换时不需要切换内存页表，速度较快。

 

### 进程和线程的区别

1、进程和线程都是并发的，但是进程是独立的程序执行实体；线程依赖于进程。

2、进程之间资源相互隔离；同一个进程下的线程共享进程的资源。

3、线程创建和销毁的开销小；进程创建和销毁的开销大。

 

 

## 浏览器进程有哪些

浏览器主进程：负责界面显示、用户交互等主要功能。

渲染进程：负责解析HTML、CSS、JavaScript，并将网页渲染成可视化内容。

GPU进程：负责处理浏览器的GPU加速任务。

网络进程：负责处理网络请求和响应，以及网络资源的下载等。

插件进程：负责浏览器插件的正常运行。

 

## 浏览器缓存

浏览器缓存遵循以下顺序：service worker缓存、内存缓存、HTTP缓存（分为强制缓存和协商缓存）、磁盘缓存、推送缓存。浏览器在查找缓存时会根据上述优先级进行查找，如果在某一级命中就不会继续查找下一级的缓存。

service worker缓存：service worker是运行在浏览器背后的独立线程，可以用来实现缓存功能，可以完全控制网络请求。由于涉及请求拦截，必须使用HTTPS协议保障安全。

内存缓存：内存中的缓存，主要包含当前页面中已经获取到的资源，如样式、脚本文件、图片等。

HTTP缓存：包括强制缓存和协商缓存。

1、强制缓存：浏览器不会向服务器发送请求，而是直接从缓存中读取资源。响应头中会使用Expires或Cache-Control来控制强制缓存，其中Cache-Control优先级高于Expires。

2、协商缓存：强制缓存失效后，浏览器会向服务器发送请求，携带缓存标识，由服务器根据缓存标识决定是否使用缓存。控制协商缓存的有响应头中的Last-Modified和请求头中的If-Modified-Since字段。

磁盘缓存：存储在磁盘中的缓存，速度比较慢，但是存储容量大，时间久。

推送缓存：HTTP/2.0以上支持，以上缓存都没有命中才使用。

 

## 浏览器渲染流程

1、解析HTML，构建DOM树。DOM树是浏览器内部表示网页内容的一种形式，包含了网页中的元素和样式。

2、解析CSS，构建CSSOM树。CSSOM树描述了每个元素的样式信息。

3、合并DOM树和CSSOM树，构建渲染树。渲染树只包含需要显示的节点和样式信息，不包含隐藏的元素和不可见的样式。

4、计算元素大小和位置，生成布局。回流发生在此阶段。

5、将每个节点和样式绘制在屏幕上。重绘发生在此阶段。

 

## 重绘和回流

重绘：页面中元素样式改变不影响布局时，浏览器只需要重新绘制元素而不需要重构页面。如改变元素颜色而不改变位置大小等。

回流：页面布局或属性发生变化，需要重新构建页面渲染树。如改变了元素的位置和大小，添加删除DOM节点等。

 

## 减少重绘和回流的方法

1、避免频繁对样式进行操作，尽可能一次修改多个样式而非多次修改一个样式。

2、避免使用table布局，因为table布局在变化时需要多次计算。

3、使用绝对定位，因为绝对定位的元素脱离了标准文档流，不会触发父元素和子元素的回流。

4、使用外部CSS文件样式而不是内联CSS样式，因为内联样式会直接修改元素的样式。

5、使用浏览器的缓存来减少更新次数。

 

## 浏览器事件机制

事件机制涉及事件触发、事件传播、事件处理。

事件触发：当用户在浏览器中进行某些操作，如点击按钮输入文本时，会触发响应的事件。事件会被封装成event对象，包含了事件的属性和方法。常见的事件类型有鼠标事件（click、mouseover、mousedown等）、键盘事件（keydown、keyup、keypress等）、表单事件（submit、input、change等）。

事件传播：分为三个阶段，捕获阶段、目标阶段、冒泡阶段。

1、捕获阶段：事件从最外层的节点上开始捕获，向下传播，直到传递到事件的目标节点。

2、目标阶段：事件到达目标节点，触发目标节点上的事件处理函数。

3、冒泡阶段：事件从目标元素向上传播，直到到达最外层节点。

事件处理：在事件处理过程中，浏览器会维护一个事件队列。一旦事件队列中的事件得到处理，就会被移除。此外，浏览器还支持宏任务和微任务的概念，用于管理异步任务。例如，setTimeout、setInterval等是宏任务，Promise回调是微任务。这些任务的执行顺序和优先级也是事件机制的一部分。

 

## 浏览器事件循环和node事件循环区别

宏任务和微任务处理不同：浏览器中宏任务和微任务通过消息队列实现。所有的异步任务会被分为宏任务和微任务，依次加入相应的队列中。当前宏任务执行完后会立刻执行所有的微任务，所有的微任务执行完后再执行下一个宏任务；而node事件循环分为6个阶段，每个阶段都会执行一些异步和同步操作。

事件类型不同：浏览器事件主要是处理用户交互事件（鼠标键盘）和网络请求等异步操作；node事件主要是处理IO请求和自定义事件。

执行环境不同：浏览器事件主要运行在JavaScript引擎和渲染引擎之间，可能会导致线程阻塞，特别是渲染和事件循环共享同一个进程的时候；node事件运行在单独的线程中，基于事件驱动模型来处理派发事件，可以处理大量并发请求。

 

## 浏览器存储

cookie：是一种小型文本文件，主要存储用户的身份认证、会话状态等信息，每次向同一个域名发送请求时都会携带cookie以识别客户端的身份。大小不超过4KB。跨域不能共享。不安全，容易被利用挟持。

localStorage：可以用来在本地永久保存数据，除非手动删除，否则会一直存在。体积大，可以存储更多的内容。不会像cookie一样被请求携带。

sessionStorage：在当前会话有效，关闭页面存储数据就会被删除。体积大，可以存储更多的内容。用于存储一些临时性的数据，相对cookie更加安全。

 

## 如何解决跨域问题

JSONP：利用script标签请求不同源的数据，但是只支持GET请求，并且需要服务器进行相应配置，不安全。

CORS：跨域资源共享。通过在服务器端配置HTTP头部信息Access-Control-Allow-Origin来允许跨域请求。支持各种HTTP方法，更加灵活安全。

代理服务器：搭建一个代理服务器来转发请求，相当于就是访问同源的代理服务器，代理服务器再去请求资源。

 

## 浏览器安全攻击方式

XSS（跨站脚本攻击）：在网页上注入恶意脚本，获取用户信息或挟持用户会话。

CSRF（跨站请求伪造）：在登录的情况下通过伪造的请求来执行未经授权的操作。

